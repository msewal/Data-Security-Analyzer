import os
import stat
from datetime import datetime # Assuming datetime is not directly needed here
from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse, JsonResponse, FileResponse, Http404
from django.contrib import messages
from .models import QuarantinedFile # Import QuarantinedFile model
# from .models import File # Assuming File model is accessed via list.models if needed
import shutil
from django.conf import settings
import json
from django.views.decorators.csrf import csrf_exempt
# import time # Assuming time is not directly needed here
import re # Keep re if needed by malware functions, though less likely than regex
import subprocess
from urllib.parse import unquote
import urllib.parse
from django.utils import timezone
import hashlib
from django.urls import reverse
import concurrent.futures
from functools import lru_cache
import threading
from django.core.cache import cache
import time
from pathlib import Path
import mimetypes
import logging
import psutil
import mmap
import io
from concurrent.futures import ThreadPoolExecutor, as_completed
import resource
from django.template.loader import get_template
from xhtml2pdf import pisa

# Import necessary functions from list.views (general helpers)
from list.views import format_size, get_owner, get_group, get_items

# Import general scanning/path helpers from regex.patterns
# is_safe_path and should_scan_file were moved here because they are used by malware scanning.
# Let's move them to a common utils file later if other apps need them.
# For now, import from here if malware needs them and they are not defined locally.
# Based on the code added, is_safe_path is used locally in malware/views.py,
# should_scan_file is also used locally. Let's check the definitions.
# Upon review, scan_and_add_files_to_db uses is_safe_path and potentially should_scan_file (commented out).
# malware_scan also uses is_safe_path and should_scan_file is not directly used.
# The malware views use is_safe_path.
# Let's keep is_safe_path and should_scan_file defined locally in malware/views.py if they are primarily used here,
# or import them from regex.patterns if they are general utilities.
# Looking at the previous edit response, is_safe_path and should_scan_file were imported from regex.patterns.
# Let's continue importing them from there for now.
from regex.patterns import should_scan_file # get_context_lines is for regex detail, not needed here

# Need to import the File model if scan_and_add_files_to_db uses it
from list.models import File

logger = logging.getLogger(__name__)

def is_safe_path(path):
    """Check if the path is safe to scan"""
    try:
        # Windows yolunu Linux yoluna çevir
        if path.startswith('C:'):
            path = '/mnt/c' + path[2:].replace('\\', '/')
        
        # Mutlak yol kontrolü
        if not os.path.isabs(path):
            return False
            
        # Tehlikeli karakterleri kontrol et
        if re.search(r'[<>:"|?*]', path):
            return False
            
        # Dosya/dizin varlığını kontrol et
        if not os.path.exists(path):
            return False
            
        # Okuma izinlerini kontrol et
        if not os.access(path, os.R_OK):
            return False
            
        return True
    except Exception as e:
        logger.error(f"Path safety check error for {path}: {str(e)}")
        return False

def normalize_path(path):
    """
    Windows yolunu Linux yoluna çevirir ve normalize eder.
    Kök dizin (/) için özel kontrol ekler.
    """
    try:
        if path == '/' or path == '\\':
            return '/'
            
        if path.startswith('C:'):
            path = '/mnt/c' + path[2:].replace('\\', '/')
        
        path = os.path.normpath(path)
        
        if not os.path.isabs(path):
            path = os.path.abspath(path)
            
        return path
    except Exception as e:
        logger.error(f"Path normalization error for {path}: {str(e)}")
        return path

# Sistem kaynakları için sabitler
MAX_WORKERS = 3  # 8 thread'li CPU için daha az worker
CHUNK_SIZE = 2 * 1024 * 1024  # 2MB chunk boyutu
MAX_MEMORY_PER_THREAD = 256 * 1024 * 1024  # 256MB
CACHE_SIZE = 512 * 1024 * 1024  # 512MB önbellek

def get_system_resources():
    """Sistem kaynaklarını kontrol eder ve uygun değerleri döndürür"""
    cpu_count = psutil.cpu_count(logical=True)
    memory = psutil.virtual_memory()
    
    # Kullanılabilir bellek miktarına göre chunk boyutunu ayarla
    available_memory = memory.available
    chunk_size = min(CHUNK_SIZE, available_memory // (MAX_WORKERS * 8))  # Daha fazla bellek boşluğu bırak
    
    # CPU kullanımına göre worker sayısını ayarla
    cpu_percent = psutil.cpu_percent(interval=1)
    if cpu_percent > 60:  # CPU kullanımı %60'ı geçtiğinde worker sayısını azalt
        workers = max(1, MAX_WORKERS - 2)
    elif cpu_percent > 40:  # CPU kullanımı %40'ı geçtiğinde worker sayısını biraz azalt
        workers = max(2, MAX_WORKERS - 1)
    else:
        workers = MAX_WORKERS
    
    # Bellek kullanımına göre chunk boyutunu ayarla
    if memory.percent > 80:  # Bellek kullanımı %80'i geçtiğinde chunk boyutunu küçült
        chunk_size = chunk_size // 2
    
    return {
        'workers': workers,
        'chunk_size': chunk_size,
        'available_memory': available_memory
    }

def scan_file_chunk(filepath, start, size):
    """Dosyanın belirli bir bölümünü tarar"""
    try:
        with open(filepath, 'rb') as f:
            # Dosyayı memory-mapped olarak aç
            with mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ) as mm:
                mm.seek(start)
                chunk = mm.read(size)
                
                logger.debug(f"Scanning chunk: {filepath} from {start} size {size}")
                # ClamAV ile chunk'ı tara (daha az agresif parametreler)
                process = subprocess.Popen(
                    ['clamscan', '--no-summary', '--scan-archive=yes', '--scan-html=yes', '--max-filesize=10M', '-'],
                    stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                
                stdout, stderr = process.communicate(input=chunk)
                logger.debug(f"ClamAV stdout: {stdout.decode()}")
                logger.debug(f"ClamAV stderr: {stderr.decode()}")
                logger.debug(f"ClamAV return code: {process.returncode}")
                return {
                    'start': start,
                    'size': size,
                    'result': stdout.decode() if stdout else '',
                    'error': stderr.decode() if stderr else None,
                    'return_code': process.returncode
                }
    except Exception as e:
        logger.error(f"Error scanning chunk at {start} in {filepath}: {str(e)}")
        return {
            'start': start,
            'size': size,
            'error': str(e),
            'return_code': -1
        }

def scan_single_file(filepath):
    """Tek bir dosyayı chunk'lar halinde tarar"""
    try:
        logger.info(f"Starting scan for single file: {filepath}")
        # Önbellekten sonuç kontrolü
        cached_result = get_cached_scan_result(filepath)
        if cached_result:
            logger.info(f"Cached result found for {filepath}. Status: {cached_result.get('status')}")
            return cached_result

        file_size = os.path.getsize(filepath)
        system_resources = get_system_resources()
        chunk_size = system_resources['chunk_size']
        
        logger.debug(f"File size: {file_size} bytes, Chunk size: {chunk_size} bytes")
        # Dosya boyutuna göre tarama stratejisini belirle
        if file_size <= chunk_size:
            # Küçük dosyalar için tek parça tarama
            logger.debug(f"Scanning small file {filepath} as single chunk.")
            chunk_result = scan_file_chunk(filepath, 0, file_size)
            if chunk_result['return_code'] == 1: # Virus bulundu
                file_hash = hashlib.md5(open(filepath, 'rb').read()).hexdigest()
                return {
                    'file': filepath,
                    'status': 'infected',
                    'details': chunk_result['result'],
                    'error': chunk_result['error'],
                    'timestamp': time.time(),
                    'hash': file_hash # Add hash for infected files
                }
            return {
                'file': filepath,
                'status': 'clean',
                'details': 'No threats found',
                'timestamp': time.time(),
                'hash': hashlib.md5(open(filepath, 'rb').read()).hexdigest() # Add hash for clean files too for completeness
            }
        else:
            # Büyük dosyalar için chunk'lar halinde tarama
            logger.debug(f"Scanning large file {filepath} in chunks.")
            chunks = []
            file_hash = hashlib.md5()
            with open(filepath, 'rb') as f:
                for chunk_data in iter(lambda: f.read(4096), b''):
                    file_hash.update(chunk_data)
            file_hash = file_hash.hexdigest()

            with ThreadPoolExecutor(max_workers=system_resources['workers']) as executor:
                futures = []
                for start in range(0, file_size, chunk_size):
                    size = min(chunk_size, file_size - start)
                    futures.append(executor.submit(scan_file_chunk, filepath, start, size))
                
                for future in as_completed(futures):
                    chunk_result = future.result()
                    logger.debug(f"Chunk scan result for {filepath} (start {chunk_result.get('start')}): Return Code {chunk_result.get('return_code')}")
                    if chunk_result['return_code'] == 1:  # Virus bulundu
                        logger.warning(f"Virus found in {filepath}: {chunk_result.get('result')}")
                        return {
                            'file': filepath,
                            'status': 'infected',
                            'details': chunk_result['result'],
                            'error': chunk_result['error'],
                            'timestamp': time.time(),
                            'hash': file_hash # Add hash for infected files
                        }
                    chunks.append(chunk_result)
            
            # Tüm chunk'lar temiz
            result = {
                'file': filepath,
                'status': 'clean',
                'details': 'No threats found',
                'timestamp': time.time(),
                'hash': file_hash # Add hash for clean files too
            }
            
            # Sonucu önbelleğe kaydet
            cache_key = f'scan_result_{hashlib.md5(filepath.encode()).hexdigest()}'
            cache.set(cache_key, result, timeout=3600)
            logger.info(f"Scan completed for {filepath}. Status: clean.")
            return result
            
    except Exception as e:
        logger.error(f"Error scanning file {filepath}: {str(e)}")
        return {
            'file': filepath,
            'status': 'error',
            'details': str(e),
            'timestamp': time.time()
        }

def should_scan_file(filepath):
    """Determine if a file should be scanned based on its type and location"""
    # Define high-risk file extensions
    high_risk_extensions = {'.exe', '.dll', '.bat', '.cmd', '.vbs', '.js', '.ps1', '.msi', '.sys'}
    # Define system directories that should be prioritized
    system_dirs = {'/Windows', '/Program Files', '/Program Files (x86)', '/System32'}
    
    # Get file extension
    _, ext = os.path.splitext(filepath.lower())
    
    # Check if file is in a system directory
    is_system_file = any(system_dir in filepath for system_dir in system_dirs)
    
    # Always scan high-risk files and system files
    if ext in high_risk_extensions or is_system_file:
        return True
    
    # Skip certain file types that are unlikely to contain malware
    skip_extensions = {'.txt', '.md', '.log', '.csv', '.json', '.xml', '.html', '.css', '.jpg', '.jpeg', '.png', '.gif', '.pdf'}
    if ext in skip_extensions:
        return False
    
    return True

def get_scan_priority(filepath):
    """Calculate scan priority for a file"""
    try:
        priority = 0

        # Check file extension
        _, ext = os.path.splitext(filepath.lower())
        high_risk_extensions = {'.exe', '.dll', '.bat', '.cmd', '.vbs', '.js', '.ps1', '.msi', '.sys'}
        if ext in high_risk_extensions:
            priority += 3

        # Check file location
        system_dirs = {'/Windows', '/Program Files', '/Program Files (x86)', '/System32'}
        for system_dir in system_dirs:
            if system_dir in filepath:
                priority += 2
                break

        # Check file size
        try:
            file_size = os.path.getsize(filepath)
            if file_size > 100 * 1024 * 1024:  # 100MB
                priority -= 1
        except OSError:
            pass

        # Check file age
        try:
            file_mtime = os.path.getmtime(filepath)
            file_age = time.time() - file_mtime
            if file_age < 24 * 3600:  # Less than 24 hours old
                priority += 1
        except OSError:
            pass

        return priority

    except Exception as e:
        logger.error(f"Error calculating scan priority for {filepath}: {str(e)}")
        return 0

def background_scan(scan_target_path, user_id, scan_archives=False, scan_id=None):
    """Perform scan in background and store results in cache"""
    try:
        # Check if target is a file or directory
        is_target_directory = os.path.isdir(scan_target_path)
        
        # Initialize scan data
        scan_data = {
            'status': 'scanning',
            'progress': 0,
            'current_file': '',
            'status_message': 'Tarama başlatılıyor...',
            'infected_files': [],
            'error': None,
            'total_files': 0,
            'scanned_files': 0
        }
        
        # Store initial scan data in cache
        cache_key = f'scan_status_{scan_id}'
        cache.set(cache_key, scan_data, timeout=3600)
        
        # Normalize and validate path
        scan_target_path = normalize_path(scan_target_path)
        if not is_safe_path(scan_target_path):
            scan_data['status'] = 'error'
            scan_data['error'] = 'Geçersiz veya güvenli olmayan dosya yolu.'
            cache.set(cache_key, scan_data, timeout=3600)
            return

        # Get system resources
        system_resources = get_system_resources()
        workers = system_resources['workers']

        # Collect files to scan
        files_to_scan = []
        if is_target_directory:
            # If target is a directory, use os.walk
            for root, _, files in os.walk(scan_target_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    if should_scan_file(file_path):
                        files_to_scan.append(file_path)
        else:
            # If target is a single file, just add it
            if should_scan_file(scan_target_path):
                files_to_scan.append(scan_target_path)

        total_files = len(files_to_scan)
        if total_files == 0:
            scan_data['status'] = 'completed'
            scan_data['progress'] = 100
            scan_data['status_message'] = 'Taranacak dosya bulunamadı.'
            cache.set(cache_key, scan_data, timeout=3600)
            return

        scan_data['total_files'] = total_files
        scan_data['status_message'] = f'Toplam {total_files} dosya taranacak.'
        cache.set(cache_key, scan_data, timeout=3600)

        # Scan files in parallel
        with ThreadPoolExecutor(max_workers=workers) as executor:
            futures = []
            for file_path in files_to_scan:
                futures.append(executor.submit(scan_single_file, file_path))

            for future in as_completed(futures):
                result = future.result()
                scan_data['scanned_files'] += 1
                scan_data['progress'] = int((scan_data['scanned_files'] / total_files) * 100)
                scan_data['current_file'] = result.get('file', '')
                scan_data['status_message'] = f'Taranan: {scan_data["scanned_files"]}/{total_files}'

                if result.get('status') == 'infected':
                    scan_data['infected_files'].append({
                        'path': result['file'],
                        'name': os.path.basename(result['file']),
                        'details': result.get('details', 'Bilinmeyen Tehdit'),
                        'hash': result.get('hash', 'N/A')
                    })
                    # Add infected file to database
                    File.objects.create(
                        path=result['file'],
                        name=os.path.basename(result['file']),
                        file_type=os.path.splitext(result['file'])[1],
                        size=os.path.getsize(result['file']),
                        malware_type=result.get('details', 'Bilinmeyen Tehdit'),
                        scan_time=timezone.now(),
                        status='infected'
                    )

                cache.set(cache_key, scan_data, timeout=3600)

        # Update scan status to completed
        scan_data['status'] = 'completed'
        scan_data['progress'] = 100
        scan_data['current_file'] = ''
        scan_data['status_message'] = f'Tarama tamamlandı. {len(scan_data["infected_files"])} tehdit bulundu.'
        cache.set(cache_key, scan_data, timeout=3600)
        
    except Exception as e:
        logger.error(f"Error in background scan: {str(e)}")
        scan_data['status'] = 'error'
        scan_data['error'] = str(e)
        cache.set(cache_key, scan_data, timeout=3600)

def scan_and_add_files_to_db(directory_path, is_target_directory=True):
    """Scan directory and add files to database"""
    try:
        # Normalize and validate path
        directory_path = normalize_path(directory_path)
        if not is_safe_path(directory_path):
            logger.error(f"Invalid or unsafe path: {directory_path}")
            return False

        # Get system resources
        system_resources = get_system_resources()
        workers = system_resources['workers']

        # Collect files to scan
        files_to_scan = []
        if is_target_directory:
            # If target is a directory, use os.walk
            for root, _, files in os.walk(directory_path):
                for file in files:
                    file_path = os.path.join(root, file)
                    if should_scan_file(file_path):
                        files_to_scan.append(file_path)
        else:
            # If target is a single file, just add it
            if should_scan_file(directory_path):
                files_to_scan.append(directory_path)

        # Scan files in parallel
        with ThreadPoolExecutor(max_workers=workers) as executor:
            futures = []
            for file_path in files_to_scan:
                futures.append(executor.submit(scan_single_file, file_path))

            for future in as_completed(futures):
                result = future.result()
                if result.get('status') == 'infected':
                    # Add infected file to database
                    File.objects.create(
                        path=result['file'],
                        name=os.path.basename(result['file']),
                        file_type=os.path.splitext(result['file'])[1],
                        size=os.path.getsize(result['file']),
                        malware_type=result.get('details', 'Bilinmeyen Tehdit'),
                        scan_time=timezone.now(),
                        status='infected'
                    )

        return True

    except Exception as e:
        logger.error(f"Error scanning directory {directory_path}: {str(e)}")
        return False

def scan_status(request):
    """API endpoint for checking scan status"""
    try:
        scan_id = request.GET.get('scan_id')
        if not scan_id:
            return JsonResponse({
                'status': 'error',
                'error': 'Tarama ID\'si belirtilmedi.'
            })

        # Get scan status from cache
        cache_key = f'scan_status_{scan_id}'
        scan_data = cache.get(cache_key)

        if not scan_data:
            return JsonResponse({
                'status': 'error',
                'error': 'Tarama bulunamadı veya süresi doldu.'
            })

        return JsonResponse({
            'status': scan_data.get('status', 'unknown'),
            'progress': scan_data.get('progress', 0),
            'current_file': scan_data.get('current_file', ''),
            'status_message': scan_data.get('status_message', ''),
            'infected_files': scan_data.get('infected_files', []),
            'error': scan_data.get('error', None)
        })

    except Exception as e:
        logger.error(f"Error checking scan status: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'error': f'Tarama durumu kontrol edilirken bir hata oluştu: {str(e)}'
        })

def malware_scan(request):
    """View for malware scanning interface"""
    try:
        # Get current path from query parameter
        current_path = request.GET.get('path', '/')
        current_path = normalize_path(current_path)

        # Get parent path
        parent_path = os.path.dirname(current_path) if current_path != '/' else None

        # Get items in current directory
        items = []
        if os.path.exists(current_path):
            for item in os.listdir(current_path):
                item_path = os.path.join(current_path, item)
                try:
                    stat_info = os.stat(item_path)
                    is_dir = os.path.isdir(item_path)
                    
                    # Get file type
                    if is_dir:
                        file_type = 'Klasör'
                    else:
                        mime_type, _ = mimetypes.guess_type(item_path)
                        file_type = mime_type or 'Bilinmeyen'

                    items.append({
                        'name': item,
                        'path': item_path,
                        'is_dir': is_dir,
                        'size': format_size(stat_info.st_size) if not is_dir else '-',
                        'permissions': oct(stat_info.st_mode)[-3:],
                        'owner': get_owner(stat_info.st_uid),
                        'group': get_group(stat_info.st_gid),
                        'modified': datetime.fromtimestamp(stat_info.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
                        'file_type_display': file_type
                    })
                except Exception as e:
                    logger.error(f"Error getting file info for {item_path}: {str(e)}")
                    continue

        # Sort items: directories first, then files
        items.sort(key=lambda x: (not x['is_dir'], x['name'].lower()))

        context = {
            'current_path': current_path,
            'parent_path': parent_path,
            'items': items
        }

        return render(request, 'malware/malware_scan.html', context)

    except Exception as e:
        logger.error(f"Error in malware_scan view: {str(e)}")
        return render(request, 'malware/malware_scan.html', {
            'error': f'Dosya listesi alınırken bir hata oluştu: {str(e)}'
        })

def malware_scan_results_view(request):
    """View to display malware scan results"""
    try:
        scan_id = request.GET.get('scan_id')
        if not scan_id:
            messages.error(request, 'Tarama ID\'si belirtilmedi.')
            return redirect('malware:malware_scan') # Redirect to scan page if no ID

        # Get scan results from cache
        cache_key = f'scan_status_{scan_id}'
        scan_data = cache.get(cache_key)

        if not scan_data:
            messages.warning(request, 'Tarama bulunamadı veya süresi doldu. Lütfen tekrar tarama yapın.')
            return redirect('malware:malware_scan') # Redirect if scan not found

        context = {
            'scan_id': scan_id,
            'scan_status': scan_data.get('status', 'unknown'),
            'scan_progress': scan_data.get('progress', 0),
            'current_file': scan_data.get('current_file', ''),
            'status_message': scan_data.get('status_message', ''),
            'infected_files': scan_data.get('infected_files', []),
            'total_files_scanned': scan_data.get('total_files_scanned', 0),
            'error': scan_data.get('error', None)
        }

        return render(request, 'malware/malware_scan_report.html', context)

    except Exception as e:
        logger.error(f"Error displaying scan results: {str(e)}")
        messages.error(request, f'Tarama sonuçları gösterilirken bir hata oluştu: {str(e)}')
        return redirect('malware:malware_scan')

def format_size(size):
    """Dosya boyutunu okunabilir formata çevirir"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} PB"

def get_owner(uid):
    """Kullanıcı ID'sini kullanıcı adına çevirir"""
    try:
        import pwd
        return pwd.getpwuid(uid).pw_name
    except Exception:
        return str(uid)

def get_group(gid):
    """Grup ID'sini grup adına çevirir"""
    try:
        import grp
        return grp.getgrgid(gid).gr_name
    except Exception:
        return str(gid)

# Quarantine List View (existing) - Keep as is
def quarantine_list(request):
    """View to display list of quarantined files"""
    try:
        quarantined_files = QuarantinedFile.objects.filter(status='quarantined').order_by('-quarantine_time')
        
        context = {
            'quarantined_files': quarantined_files
        }
        
        return render(request, 'malware/quarantine_list.html', context)
        
    except Exception as e:
        logger.error(f"Error displaying quarantine list: {str(e)}")
        return render(request, 'malware/quarantine_list.html', {
            'error': f'Karantina listesi gösterilirken bir hata oluştu: {str(e)}'
        })

# Quarantine Restore View (existing)
def quarantine_restore(request, filename):
    """Restore a file from quarantine"""
    try:
        # Get quarantined file
        quarantined_file = get_object_or_404(QuarantinedFile, filename=filename, status='quarantined')

        # Check if original directory exists
        original_dir = os.path.dirname(quarantined_file.original_path)
        if not os.path.exists(original_dir):
            os.makedirs(original_dir)

        # Restore file
        shutil.move(quarantined_file.quarantine_path, quarantined_file.original_path)

        # Update status
        quarantined_file.status = 'restored'
        quarantined_file.restore_time = timezone.now()
        quarantined_file.save()

        messages.success(request, f'{filename} başarıyla geri yüklendi.')
        return redirect('malware:quarantine_list')

    except Exception as e:
        logger.error(f"Error restoring file {filename}: {str(e)}")
        messages.error(request, f'Dosya geri yüklenirken bir hata oluştu: {str(e)}')
        return redirect('malware:quarantine_list')

# Quarantine Delete View (existing)
def quarantine_delete(request, filename):
    """Delete a file from quarantine"""
    try:
        # Get quarantined file
        quarantined_file = get_object_or_404(QuarantinedFile, filename=filename, status='quarantined')

        # Delete file from quarantine
        if os.path.exists(quarantined_file.quarantine_path):
            os.remove(quarantined_file.quarantine_path)

        # Update status
        quarantined_file.status = 'deleted'
        quarantined_file.delete_time = timezone.now()
        quarantined_file.save()

        messages.success(request, f'{filename} başarıyla silindi.')
        return redirect('malware:quarantine_list')

    except Exception as e:
        logger.error(f"Error deleting file {filename}: {str(e)}")
        messages.error(request, f'Dosya silinirken bir hata oluştu: {str(e)}')
        return redirect('malware:quarantine_list')

# API Endpoint for Malware Scan (moved from list/views.py)
@csrf_exempt
def api_malware_scan(request):
    """API endpoint for starting a malware scan"""
    try:
        data = json.loads(request.body)
        scan_target_path = data.get('scan_target_path')
        scan_archives = data.get('scan_archives', False)

        if not scan_target_path:
            return JsonResponse({
                'status': 'error',
                'error': 'Tarama hedefi belirtilmedi.'
            })

        # Normalize and validate path
        scan_target_path = normalize_path(scan_target_path)
        if not is_safe_path(scan_target_path):
            return JsonResponse({
                'status': 'error',
                'error': 'Geçersiz veya güvenli olmayan dosya yolu.'
            })

        # Generate a unique scan ID
        scan_id = hashlib.md5(f"{scan_target_path}_{time.time()}".encode()).hexdigest()

        # Start background scan
        thread = threading.Thread(
            target=background_scan,
            args=(scan_target_path, request.user.id, scan_archives),
            kwargs={'scan_id': scan_id}
        )
        thread.daemon = True
        thread.start()

        return JsonResponse({
            'status': 'success',
            'scan_id': scan_id,
            'message': 'Tarama başlatıldı.'
        })

    except Exception as e:
        logger.error(f"Error starting scan: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'error': f'Tarama başlatılırken bir hata oluştu: {str(e)}'
        })

# API Endpoint for Quarantine (moved from list/views.py)
@csrf_exempt
def api_quarantine(request):
    """API endpoint for quarantining files"""
    try:
        data = json.loads(request.body)
        file_path = data.get('file_path')

        if not file_path:
            return JsonResponse({
                'status': 'error',
                'error': 'Dosya yolu belirtilmedi.'
            })

        # Normalize and validate path
        file_path = normalize_path(file_path)
        if not is_safe_path(file_path):
            return JsonResponse({
                'status': 'error',
                'error': 'Geçersiz veya güvenli olmayan dosya yolu.'
            })

        # Quarantine the file
        try:
            quarantine_file(file_path, request.user.id)
            return JsonResponse({
                'status': 'success',
                'message': 'Dosya başarıyla karantinaya alındı.'
            })
        except Exception as e:
            logger.error(f"Error quarantining file {file_path}: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': f'Dosya karantinaya alınırken bir hata oluştu: {str(e)}'
            })

    except Exception as e:
        logger.error(f"Error in api_quarantine: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'error': f'Karantina işlemi sırasında bir hata oluştu: {str(e)}'
        })

def get_cached_scan_result(filepath):
    """Get cached scan result for a file"""
    try:
        # Generate cache key from file path
        cache_key = f'scan_result_{hashlib.md5(filepath.encode()).hexdigest()}'
        
        # Get cached result
        cached_result = cache.get(cache_key)
        
        if cached_result:
            # Check if file has been modified since last scan
            file_mtime = os.path.getmtime(filepath)
            if file_mtime <= cached_result.get('timestamp', 0):
                return cached_result
        
        return None

    except Exception as e:
        logger.error(f"Error getting cached scan result for {filepath}: {str(e)}")
        return None

def quarantine_file(file_path, user_id):
    """Quarantine a file by moving it to the quarantine directory"""
    try:
        # Create quarantine directory if it doesn't exist
        quarantine_dir = os.path.join(settings.MEDIA_ROOT, 'quarantine')
        os.makedirs(quarantine_dir, exist_ok=True)

        # Generate quarantine filename
        filename = os.path.basename(file_path)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        quarantine_filename = f"{timestamp}_{filename}"
        quarantine_path = os.path.join(quarantine_dir, quarantine_filename)

        # Calculate file hash
        file_hash = hashlib.md5()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                file_hash.update(chunk)
        file_hash = file_hash.hexdigest()

        # Move file to quarantine
        shutil.move(file_path, quarantine_path)

        # Create quarantine record
        QuarantinedFile.objects.create(
            filename=filename,
            original_path=file_path,
            quarantine_path=quarantine_path,
            file_size=os.path.getsize(quarantine_path),
            file_hash=file_hash,
            quarantine_time=timezone.now(),
            user_id=user_id,
            status='quarantined'
        )

        return True

    except Exception as e:
        logger.error(f"Error quarantining file {file_path}: {str(e)}")
        raise

def generate_pdf_report(request, scan_id):
    """Generates a PDF report for a given scan ID"""
    try:
        cache_key = f'scan_status_{scan_id}'
        scan_data = cache.get(cache_key)

        if not scan_data:
            messages.warning(request, 'Tarama bulunamadı veya süresi doldu.')
            return redirect('malware:malware_scan')

        # Prepare context for PDF template
        context = {
            'scan_id': scan_id,
            'scan_status': scan_data.get('status', 'unknown'),
            'scan_progress': scan_data.get('progress', 0),
            'current_file': scan_data.get('current_file', ''),
            'status_message': scan_data.get('status_message', ''),
            'infected_files': scan_data.get('infected_files', []),
            'total_files_scanned': scan_data.get('total_files_scanned', 0),
            'total_scanned_size': scan_data.get('total_scanned_size', 'N/A'),
            'scan_start_time': scan_data.get('scan_start_time', 'N/A'),
            'scan_end_time': scan_data.get('scan_end_time', 'N/A'),
            'scan_duration': scan_data.get('scan_duration', 'N/A'),
            'scanned_by': scan_data.get('scanned_by', 'Misafir'),
            'total_clean_files': scan_data.get('total_clean_files', 0),
            'error': scan_data.get('error', None),
            'request': request # Pass request to context for user info
        }

        # Add scan profile determination here for PDF context
        scan_target_path_for_profile = scan_data.get('scan_target_path', '')
        if os.path.isfile(scan_target_path_for_profile):
            context['scan_profile'] = 'Tek Dosya Tarama'
        else:
            context['scan_profile'] = 'Tam Klasör Tarama'

        # Load template and render HTML
        template_path = 'malware/malware_scan_report_pdf.html' # A new template for PDF
        template = get_template(template_path)
        html = template.render(context)

        # Create PDF
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="malware_scan_report_{scan_id}.pdf"'
        
        pisa_status = pisa.CreatePDF(html, dest=response)
        if pisa_status.err:
            return HttpResponse('PDF oluşturulurken bir hata oluştu: %s' % pisa_status.err, status=500)
        return response

    except Exception as e:
        logger.error(f"Error generating PDF report for scan ID {scan_id}: {str(e)}")
        messages.error(request, f'PDF raporu oluşturulurken bir hata oluştu: {str(e)}')
        return redirect('malware:malware_scan_results', scan_id=scan_id)
