import os
import stat
from datetime import datetime # Assuming datetime is not directly needed here
from django.shortcuts import render, redirect, get_object_or_404
from django.http import HttpResponse, JsonResponse, FileResponse, Http404
from django.contrib import messages
from .models import QuarantinedFile # Import QuarantinedFile model
# from .models import File # Assuming File model is accessed via list.models if needed
import shutil
from django.conf import settings
import json
from django.views.decorators.csrf import csrf_exempt
# import time # Assuming time is not directly needed here
import re # Keep re if needed by malware functions, though less likely than regex
import subprocess
from urllib.parse import unquote
import urllib.parse
from django.utils import timezone
import hashlib

# Import necessary functions from list.views (general helpers)
from list.views import format_size, get_owner, get_group, get_items

# Import general scanning/path helpers from regex.patterns
# is_safe_path and should_scan_file were moved here because they are used by malware scanning.
# Let's move them to a common utils file later if other apps need them.
# For now, import from here if malware needs them and they are not defined locally.
# Based on the code added, is_safe_path is used locally in malware/views.py,
# should_scan_file is also used locally. Let's check the definitions.
# Upon review, scan_and_add_files_to_db uses is_safe_path and potentially should_scan_file (commented out).
# malware_scan also uses is_safe_path and should_scan_file is not directly used.
# The malware views use is_safe_path.
# Let's keep is_safe_path and should_scan_file defined locally in malware/views.py if they are primarily used here,
# or import them from regex.patterns if they are general utilities.
# Looking at the previous edit response, is_safe_path and should_scan_file were imported from regex.patterns.
# Let's continue importing them from there for now.
from regex.patterns import should_scan_file # get_context_lines is for regex detail, not needed here

# Need to import the File model if scan_and_add_files_to_db uses it
from list.models import File

# Define is_safe_path locally
def is_safe_path(path):
    """Check if the path is safe to scan"""
    # Add your path safety checks here
    return True

# Helper function to check if a tool is available (moved from original malware_scan logic)
def is_tool_available(name):
    """Check if a command-line tool is available in the system's PATH."""
    return shutil.which(name) is not None

# Malware Scan View (existing)
def malware_scan(request):
    current_path = request.GET.get('path', '/') # Path for browsing
    scan_target_path = request.GET.get('scan_path') # Path for scanning

    if scan_target_path:
        # Add safety check for scan_target_path
        if not is_safe_path(scan_target_path):
            messages.error(request, f"Güvenli olmayan yol: {scan_target_path}")
            return redirect('malware:malware_scan') # Redirect back to the scan page

        # Perform scan if scan_path is provided
        error = None
        infected_files = []
        scan_results = []
        clam_output = None
        rkhunter_output = None
        chkrootkit_output = None

        if not os.path.exists(scan_target_path):
            error = f"Tarama hedefi bulunamadı: {scan_target_path}"
        else:
            # Check if clamscan is available
            if not is_tool_available("clamscan"):
                scan_results.append({
                    'tool': 'system',
                    'message': "ClamAV (clamscan) bulunamadı. Lütfen kurulu olduğundan ve PATH'inizde bulunduğundan emin olun."
                 })
            else:
                try:
                    # ClamAV taraması
                    clam_command = ["clamscan", "-r", scan_target_path]
                    print(f"Running command: {' '.join(clam_command)}") # Log the command
                    clam_result = subprocess.run(
                        clam_command,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        text=True,
                        check=True # Add check=True to catch non-zero exit codes
                    )
                    clam_output = clam_result.stdout
                    
                    for line in clam_result.stdout.splitlines():
                        if " FOUND" in line: # Note the space before FOUND to avoid matching file paths containing "FOUND"
                            parts = line.split(":")
                            if len(parts) >= 2:
                                filepath = parts[0].strip()
                                malware_type = parts[-1].strip()
                                
                                # Add safety check before attempting to quarantine
                                if is_safe_path(filepath) and os.path.exists(filepath):
                                    filename = os.path.basename(filepath)
                                    quarantine_dir = settings.QUARANTINE_DIR # Use settings for quarantine dir
                                    
                                    # Ensure quarantine directory exists
                                    os.makedirs(quarantine_dir, exist_ok=True)

                                    # Handle potential filename collisions in quarantine
                                    base, ext = os.path.splitext(filename)
                                    counter = 1
                                    quarantine_filename = filename
                                    while os.path.exists(os.path.join(quarantine_dir, quarantine_filename + '.quarantine')):
                                         quarantine_filename = f"{base}_{counter}{ext}"
                                         counter += 1
                                    quarantine_path = os.path.join(quarantine_dir, quarantine_filename + '.quarantine')

                                    try:
                                        shutil.move(filepath, quarantine_path)
                                        messages.success(request, f'{filename} karantinaya taşındı.')
                                        # Veritabanına kaydet - Using QuarantinedFile model
                                        # Need to calculate file size and hash after moving
                                        file_size = os.path.getsize(quarantine_path)
                                        sha256_hash = "N/A" # TODO: Calculate hash for quarantined file
                                        try:
                                            sha256 = hashlib.sha256()
                                            with open(quarantine_path, "rb") as f:
                                                for byte_block in iter(lambda: f.read(4096), b""):
                                                    sha256.update(byte_block)
                                            sha256_hash = sha256.hexdigest()
                                        except Exception as hash_error:
                                            print(f"Error calculating hash for quarantined file {quarantine_path}: {hash_error}")

                                        QuarantinedFile.objects.create(
                                            filename=filename,
                                            original_path=filepath,
                                            quarantine_path=quarantine_path,
                                            malware_type=malware_type,
                                            scan_tool='clamscan',
                                            file_size=file_size,
                                            file_hash=sha256_hash,
                                            detected_by_user=request.user.username if request.user.is_authenticated else "Anonymous",
                                            threat_level='medium' # TODO: Determine threat level based on malware_type
                                        )
                                        
                                        infected_files.append({
                                            'path': filepath,
                                            'malware_type': malware_type,
                                            'tool': 'clamscan'
                                        })
                                    except Exception as move_quarantine_error:
                                         scan_results.append({
                                             'tool': 'system',
                                             'message': f'Dosya karantinaya taşınırken hata oluştu {filepath}: {move_quarantine_error}'
                                         })
                                else:
                                     scan_results.append({
                                         'tool': 'clamscan',
                                         'message': f'Tespit edilen dosya karantina için bulunamadı veya güvenli olmayan yol: {filepath}'
                                     })
                            else:
                                scan_results.append({
                                    'tool': 'clamscan',
                                    'message': f'Clamscan çıktısı ayrıştırılırken hata: {line}'
                                })

                    # RKHunter taraması (rootkit tespiti) - Only for directories
                    if os.path.isdir(scan_target_path):
                         if not is_tool_available("rkhunter"):
                             scan_results.append({
                                'tool': 'system',
                                'message': "RKHunter bulunamadı. Lütfen kurulu olduğundan ve PATH'inizde bulunduğundan emin olun."
                             })
                         else:
                             try:
                                 # Pass command and arguments as a list without shell=True
                                 rkhunter_command = ["rkhunter", "--check", scan_target_path]
                                 print(f"Running command: {' '.join(rkhunter_command)}") # Log the command
                                 rkhunter_result = subprocess.run(
                                     rkhunter_command,
                                     stdout=subprocess.PIPE,
                                     stderr=subprocess.PIPE,
                                     text=True,
                                     check=True
                                 )
                                 rkhunter_output = rkhunter_result.stdout
                                 for line in rkhunter_result.stdout.splitlines():
                                     if "Warning:" in line:
                                         scan_results.append({
                                             'tool': 'rkhunter',
                                             'message': line.strip()
                                         })
                             except (subprocess.CalledProcessError, FileNotFoundError) as e:
                                 scan_results.append({
                                     'tool': 'rkhunter',
                                     'message': f'RKHunter çalıştırılırken hata oluştu: {e}'
                                 })

                    # Chkrootkit taraması - Only for directories
                    if os.path.isdir(scan_target_path):
                        if not is_tool_available("chkrootkit"):
                            scan_results.append({
                                'tool': 'system',
                                'message': "Chkrootkit bulunamadı. Lütfen kurulu olduğundan ve PATH'inizde bulunduğundan emin olun."
                             })
                        else:
                             try:
                                 # Pass command and arguments as a list without shell=True
                                 # Chkrootkit often requires root. This might fail without appropriate permissions.
                                 chkrootkit_command = ["sudo", "chkrootkit", scan_target_path] # Use sudo as it often requires root
                                 print(f"Running command: {' '.join(chkrootkit_command)}") # Log the command
                                 chkrootkit_result = subprocess.run(
                                     chkrootkit_command,
                                     stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE, 
                                     text=True,
                                     check=True
                                 )
                                 chkrootkit_output = chkrootkit_result.stdout
                                 for line in chkrootkit_result.stdout.splitlines():
                                     if "INFECTED" in line:
                                         scan_results.append({
                                             'tool': 'chkrootkit',
                                             'message': line.strip()
                                         })
                             except (subprocess.CalledProcessError, FileNotFoundError) as e:
                                 scan_results.append({
                                     'tool': 'chkrootkit',
                                     'message': f'Chkrootkit çalıştırılırken hata oluştu: {e}. Root izni gerekebilir.'
                                 })
                             except Exception as e: # Catch other potential errors like permission issues with sudo
                                 scan_results.append({
                                     'tool': 'chkrootkit',
                                     'message': f'Chkrootkit çalıştırılırken beklenmeyen hata oluştu: {e}'
                                 })

                except FileNotFoundError as e:
                     # This specifically catches if the command *itself* was not found
                     error = f"Tarama aracı bulunamadı: {e.strerror} ({e.filename}). Lütfen kurulu olduklarından ve PATH'inizde bulunduklarından emin olun."
                except subprocess.CalledProcessError as e:
                    # This catches errors from the scan command itself (non-zero exit code)
                    # The output might be in stderr or stdout depending on the tool
                    command_output = e.stdout + "\n" + e.stderr
                    error = f"Tarama komutu çalıştırılırken hata oluştu ({e.cmd}). Çıkış kodu: {e.returncode}. Çıktı:\n{command_output}"
                except Exception as e:
                    error = f"Tarama sırasında beklenmeyen bir hata oluştu: {str(e)}"
                    
        # Store results in session
        request.session['malware_scan_results'] = {
            'scan_target_path': scan_target_path,
            'infected_files': infected_files,
            'scan_results': scan_results,
            'clam_output': clam_output,
            'rkhunter_output': rkhunter_output,
            'chkrootkit_output': chkrootkit_output,
            'error': error,
            'is_scanning': True # Indicate that a scan was just performed
        }
        
        # Redirect to results page
        return redirect('malware:malware_scan_results')

    # If no scan_path, just display file browser
    request.session.pop('malware_scan_results', None) # Clear previous results
    
    items = []
    error = None # Clear any previous error related to scanning for the file browser view
    
    # Add safety check for current_path for file browsing
    if not is_safe_path(current_path):
         messages.error(request, f"Güvenli olmayan yol: {current_path}")
         # Attempt to redirect to root or a safe default path
         current_path = '/'
         # Re-check if root is safe, although it should be
         if not is_safe_path(current_path):
              error = "Sistem hatası: Çalışma alanı kök dizinine erişilemiyor."
              items = [] # Clear items if even root is unsafe
         else:
             try:
                 items = get_items(current_path)
             except Exception as e:
                 error = f"Klasör içeriği listelenirken bir hata oluştu: {str(e)}"
                 items = []

    elif os.path.exists(current_path) and os.path.isdir(current_path):
        try:
            # Use get_items from list.views
            items = get_items(current_path)
        except Exception as e: # Catch exceptions for listing directory
            error = f"Klasör içeriği listelenirken bir hata oluştu: {str(e)}"
            items = [] # Clear items on error
    elif os.path.exists(current_path) and os.path.isfile(current_path):
         # If the path is a file, just list the file itself
         try:
            stat_info = os.stat(current_path)
            # Need format_size and format_time from list.views
            file_type_display = os.path.splitext(os.path.basename(current_path))[1].upper()[1:] + ' Dosyası' if os.path.splitext(os.path.basename(current_path))[1] else 'Dosya'
            items.append({
                'name': os.path.basename(current_path),
                'path': current_path,
                'is_dir': False,
                'size': format_size(stat_info.st_size),
                'permissions': oct(stat_info.st_mode)[-3:],
                'owner': get_owner(stat_info.st_uid),
                'group': get_group(stat_info.st_gid),
                'modified': datetime.fromtimestamp(stat_info.st_mtime).strftime('%Y-%m-%d %H:%M:%S'),
                'file_type_display': file_type_display
            })
         except Exception as e:
             error = f"Dosya bilgileri alınırken bir hata oluştu: {str(e)}"
             items = []
    else:
        error = f"Geçerli yol bulunamadı veya bir klasör değil: {current_path}"
        items = []

    context = {
        'current_path': current_path,
        'parent_path': os.path.dirname(current_path) if is_safe_path(os.path.dirname(current_path)) else '/', # Ensure parent path is also safe
        'items': items,
        'error': error
    }

    # Check if it's an AJAX request (for file browsing)
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({
            'success': error is None,
            'data': {
                'current_path': context['current_path'],
                'parent_path': context['parent_path'],
                'items': context['items']
            },
            'error': error
        })

    return render(request, 'malware/malware_scan.html', context)

# Malware Scan Results View (existing) - No changes needed based on move
def malware_scan_results_view(request):
    # Retrieve results from session
    scan_results_data = request.session.pop('malware_scan_results', None)
    
    if not scan_results_data:
        # If no results in session, redirect to scan page
        messages.warning(request, 'Tarama sonuçları bulunamadı. Lütfen tekrar tarama yapın.')
        return redirect('malware:malware_scan')

    context = {
        'scan_target_path': scan_results_data.get('scan_target_path'),
        'infected_files': scan_results_data.get('infected_files', []),
        'scan_results': scan_results_data.get('scan_results', []),
        'clam_output': scan_results_data.get('clam_output'),
        'rkhunter_output': scan_results_data.get('rkhunter_output'),
        'chkrootkit_output': scan_results_data.get('chkrootkit_output'),
        'error': scan_results_data.get('error'),
        'is_scanning': scan_results_data.get('is_scanning', False)
    }
    
    return render(request, 'malware/malware_scan_result.html', context)

# Quarantine List View (existing) - Keep as is
def quarantine_list(request):
    # Assuming QuarantinedFile model is accessible
    quarantined_files = QuarantinedFile.objects.all().order_by('-quarantine_time')
    return render(request, 'malware/quarantine.html', {'quarantined_files': quarantined_files})

# Quarantine Restore View (existing)
def quarantine_restore(request, filename):
    try:
        # Use get_object_or_404 to get the QuarantinedFile instance
        quarantined_file = get_object_or_404(QuarantinedFile, filename=filename, status='quarantined')

        original_path = quarantined_file.original_path
        quarantine_path = quarantined_file.quarantine_path

        # Add safety check for original_path before restoring
        if not is_safe_path(original_path):
             messages.error(request, f"Güvenli olmayan hedef yol: {original_path}")
             return redirect('malware:quarantine_list') # Redirect back to list

        try:
            # Ensure the target directory for restoration exists
            os.makedirs(os.path.dirname(original_path), exist_ok=True)
            
            # Restore file logic: move from quarantine back to original path
            shutil.move(quarantine_path, original_path)
            
            # Update status in the database
            quarantined_file.status = 'restored'
            quarantined_file.save()

            messages.success(request, f'{filename} başarıyla geri yüklendi.')

            return redirect('malware:quarantine_list') # Redirect back to list
        except FileNotFoundError:
             messages.error(request, f'Karantina dosyası bulunamadı: {quarantine_path}')
             return redirect('malware:quarantine_list')
        except Exception as e:
            print(f"Error restoring file {filename}: {e}") # Log the error
            messages.error(request, f'{filename} geri yüklenirken hata oluştu: {str(e)}')
            return redirect('malware:quarantine_list')

    except Http404:
        messages.error(request, f'Karantina dosyası ({filename}) bulunamadı veya zaten geri yüklendi/silindi.')
        return redirect('malware:quarantine_list')
    except Exception as e:
        print(f"Error accessing quarantined file {filename}: {e}") # Log the error
        messages.error(request, f'Karantina dosyasına erişilirken hata oluştu ({filename}): {str(e)}')
        return redirect('malware:quarantine_list')

# Quarantine Delete View (existing)
def quarantine_delete(request, filename):
    try:
        # Use get_object_or_404 to get the QuarantinedFile instance
        # Allow deleting files that are not just 'quarantined' in case of errors
        quarantined_file = get_object_or_404(QuarantinedFile, filename=filename)

        quarantine_path = quarantined_file.quarantine_path

        # Add safety check for quarantine_path before deleting
        if not is_safe_path(quarantine_path) or not os.path.exists(quarantine_path):
             messages.error(request, f"Güvenli olmayan veya bulunamayan karantina yolu: {quarantine_path}")
             # Update status in DB even if file not found on disk for consistency
             quarantined_file.status = 'deleted'
             quarantined_file.save()
             return redirect('malware:quarantine_list')

        try:
            # Delete file logic: remove from quarantine directory
            os.remove(quarantine_path)
            
            # Update status in the database
            quarantined_file.status = 'deleted'
            quarantined_file.save()

            messages.success(request, f'{filename} karantinadan kalıcı olarak silindi.')

            return redirect('malware:quarantine_list') # Redirect back to list
        except FileNotFoundError:
             messages.error(request, f'Karantina dosyası bulunamadı: {quarantine_path}')
             # Update status in DB even if file not found on disk for consistency
             quarantined_file.status = 'deleted'
             quarantined_file.save()
             return redirect('malware:quarantine_list')
        except Exception as e:
            print(f"Error deleting file {filename}: {e}") # Log the error
            messages.error(request, f'{filename} silinirken hata oluştu: {str(e)}')
            return redirect('malware:quarantine_list')

    except Http404:
        messages.error(request, f'Karantina dosyası ({filename}) bulunamadı.')
        return redirect('malware:quarantine_list')
    except Exception as e:
        print(f"Error accessing quarantined file {filename}: {e}") # Log the error
        messages.error(request, f'Karantina dosyasına erişilirken hata oluştu ({filename}): {str(e)}')
        return redirect('malware:quarantine_list')

# API Endpoint for Malware Scan (moved from list/views.py)
@csrf_exempt
def api_malware_scan(request):
    if request.method == 'POST': # Assuming API scan is triggered by POST
        data = json.loads(request.body)
        path = data.get("path")

        if not path:
            return JsonResponse({"error": True, "msg": "Path parameter required."})

        # Add safety check for path traversal
        if not os.path.exists(path) or not is_safe_path(path):
             return JsonResponse({"error": True, "msg": f"File not found or access denied: {path}"}) # More specific error

        # This API endpoint likely triggers a scan and returns results.
        # It might call the same scanning logic as malware_scan view but return JSON.
        # Let's reuse the core scanning logic if possible or replicate it here.
        # For now, let's replicate a simplified version or call a helper that performs the scan.
        # A better approach would be a dedicated scanning service/helper.

        scan_results = []
        infected_files_summary = [] # Simplified output for API
        error_message = None

        # Check if clamscan is available
        if not is_tool_available("clamscan"):
            error_message = "ClamAV (clamscan) not found."
            scan_results.append({'tool': 'system', 'message': error_message})
        else:
            try:
                # Simplified scan logic for API - just check for FOUND signature
                clam_command = ["clamscan", "--no-summary", path] # Use --no-summary for cleaner output
                clam_result = subprocess.run(
                    clam_command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=False # Don't raise exception on non-zero exit code (e.g., if virus found)
                )

                if clam_result.returncode == 0: # Clean scan
                     scan_results.append({'tool': 'clamscan', 'message': 'No threats found.'}) # Or similar success message
                elif clam_result.returncode == 1: # Found virus
                     error_message = "Threats found."
                     # Parse output to find infected files
                     for line in clam_result.stdout.splitlines():
                         if " FOUND" in line:
                             parts = line.split(":")
                             if len(parts) >= 2:
                                 filepath = parts[0].strip()
                                 malware_type = parts[-1].strip()
                                 infected_files_summary.append({'path': filepath, 'type': malware_type, 'tool': 'clamscan'})
                                 scan_results.append({'tool': 'clamscan', 'message': f'Threat found: {malware_type} in {filepath}'})
                else: # Other error codes
                     error_message = f"Clamscan error (exit code {clam_result.returncode}): {clam_result.stderr.strip()}"
                     scan_results.append({'tool': 'clamscan', 'message': error_message})

            except FileNotFoundError:
                 error_message = "Clamscan command not found."
                 scan_results.append({'tool': 'system', 'message': error_message})
            except Exception as e:
                error_message = f"An error occurred during clamscan: {str(e)}"
                scan_results.append({'tool': 'system', 'message': error_message})

        # In a real API, you might want to trigger async scanning for large files/directories

        return JsonResponse({
            "error": error_message is not None,
            "msg": error_message if error_message else "Scan complete.",
            "infected_files": infected_files_summary,
            "scan_results": scan_results # Provide detailed tool output/messages
        })
    
    return JsonResponse({'error': True, 'msg': 'Method not allowed'}, status=405)

# API Endpoint for Quarantine (moved from list/views.py)
@csrf_exempt
def api_quarantine(request):
    if request.method == 'POST': # Assuming API quarantine is triggered by POST
        data = json.loads(request.body)
        path = data.get("path")
        reason = data.get("reason", "API Quarantine Request")
        scan_type = data.get("scan_type", "API Scan")

        if not path:
            return JsonResponse({"error": True, "msg": "Path parameter required."})

        # Add safety check for path traversal
        if not os.path.exists(path) or not os.path.isfile(path) or not is_safe_path(path):
             return JsonResponse({"error": True, "msg": f"File not found, is not a file or access denied: {path}"}) # More specific error

        try:
            # Check if file is already quarantined to avoid duplicates
            if QuarantinedFile.objects.filter(original_path=path, status='quarantined').exists():
                 return JsonResponse({"error": False, "msg": f"File already quarantined: {path}"})

            # Use the create_from_file class method of the QuarantinedFile model
            quarantined_file_instance = QuarantinedFile.create_from_file(path, reason, scan_type)
            messages.success(request, f'{os.path.basename(path)} karantinaya alındı.') # Show message on next page load

            return JsonResponse({
                "error": False,
                "msg": f"File quarantined successfully: {os.path.basename(path)}",
                "quarantined_file": {
                    "id": quarantined_file_instance.id,
                    "filename": quarantined_file_instance.filename,
                    "original_path": quarantined_file_instance.original_path,
                    "quarantine_path": quarantined_file_instance.quarantine_path,
                    "malware_type": quarantined_file_instance.malware_type,
                    "scan_tool": quarantined_file_instance.scan_tool,
                    "quarantine_time": quarantined_file_instance.quarantine_time.isoformat(),
                    "file_size": quarantined_file_instance.file_size,
                    "file_hash": quarantined_file_instance.file_hash,
                    "threat_level": quarantined_file_instance.threat_level,
                    "status": quarantined_file_instance.status,
                }
            })
        except Exception as e:
            print(f"Error quarantining file {path}: {e}") # Log the error
            return JsonResponse({"error": True, "msg": f"Error quarantining file: {str(e)}"}) # Return error message

    return JsonResponse({'error': True, 'msg': 'Method not allowed'}, status=405)

# Function to scan a directory and add files to the File model (moved from list/views.py)
# This function interacts with the File model, which is in the list app.
# Need to import the File model.
def scan_and_add_files_to_db(directory_path):
    """Scans a directory and adds files to the File model."""
    # Add safety check for directory_path
    if not is_safe_path(directory_path) or not os.path.isdir(directory_path):
        print(f"Skipping scan of unsafe or non-directory path: {directory_path}")
        # Consider adding logging or raising an error
        return

    print(f"Starting scan of {directory_path} to add files to database.")
    processed_count = 0
    added_count = 0
    for root, _, files in os.walk(directory_path):
        for file in files:
            file_path = os.path.join(root, file)
            processed_count += 1
            # Avoid adding directories as files or adding hidden files/system files
            # Also, only process safe paths and potentially use should_scan_file if applicable
            if os.path.isfile(file_path) and not os.path.basename(file_path).startswith('.') and is_safe_path(file_path): # Added is_safe_path check
                 # Add should_scan_file check if this function is intended for scan targets
                 # if should_scan_file(file_path):
                    try:
                        # Check if file already exists in DB to avoid duplicates based on path
                        # Using get_or_create is a more atomic way to handle this.
                        obj, created = File.objects.get_or_create(
                            path=file_path,
                            defaults={
                                'name': file,
                                # 'size': os.path.getsize(file_path), # Get size on create
                                'is_directory': False,
                                # owner, group, permissions, mime_type can be added here if easily obtainable
                                # 'owner': get_owner(os.stat(file_path).st_uid), # Requires get_owner
                                # 'group': get_group(os.stat(file_path).st_gid), # Requires get_group
                                # 'permissions': oct(os.stat(file_path).st_mode)[-3:], # Requires os.stat
                                # scan_status and scan_result will default to pending/empty
                            }
                        )
                        
                        if created:
                            # Update size after creation for robustness
                            obj.size = os.path.getsize(file_path)
                            # You might also want to update other metadata if they change
                            # obj.owner = get_owner(os.stat(file_path).st_uid)
                            # obj.group = get_group(os.stat(file_path).st_gid)
                            # obj.permissions = oct(os.stat(file_path).st_mode)[-3:]
                            obj.save()
                            print(f"Added file to DB: {file_path}")
                            added_count += 1
                        else:
                            # If file already exists, you might want to update its metadata (size, modified_at etc.)
                            # For now, just print that it exists.
                            # print(f"File already in DB: {file_path}")
                            pass # Keep quiet for existing files unless updating
                    except Exception as e:
                        print(f"Error adding file {file_path} to DB: {str(e)}")
    print(f"Finished scanning {directory_path}. Processed {processed_count} files, added {added_count} new files to database.")

# Example usage (you might want to trigger this from a management command or a specific view)
# scan_and_add_files_to_db('/path/to/your/project')
